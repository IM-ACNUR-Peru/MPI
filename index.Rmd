---
title: "Multidimensional Poverty Index (MPI) for Venezualan in Peru"
subtitle: "ENPOVE"
date: "2022"
author: IM-ACNUR
output:
  unhcrdown::html_page:
    toc: true
    toc_depth: 2
    toc_float: true
---

## Introducción

:::{.lead}
 the Multidimensional Poverty Index (MPI) developed by Sabina Alkire and James Foster is a widely recognized measure of poverty that goes beyond income-based indicators. The MPI assesses poverty based on multiple dimensions, such as health, education, and standard of living. It identifies individuals who are simultaneously deprived in multiple aspects of their lives, providing a more comprehensive understanding of poverty. The MPI assigns a deprivation score to each individual and aggregates these scores to calculate the overall poverty rate. It is a valuable tool for policymakers and researchers to design targeted interventions and monitor progress in poverty reduction efforts. 
:::

 
```{r echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.cap = TRUE, message = FALSE, warning = FALSE, fig.height = 8, fig.width = 9) 
```

```{r library}
library(officedown)
library(unhcrthemes)
library(fontawesome)
library(haven)
library(dplyr)
library(scales)
library(tidyverse)

library(sjPlot)

# turn off the automatic use of showtext functionality, so that the dml function can works properly
showtext::showtext_auto(FALSE)
## Reference #####
# https://martinctc.github.io/blog/working-with-spss-labels-in-r/
```


```{r load_specs_file} 
# install.packages("devtools")
#devtools::install_github('yng-me/mpindex')

library(mpindex)

# ----------------------------------
# Load MPI specs from the built-in specs file
#write.csv( read.csv(system.file("extdata", "global-mpi-specs.csv", package = "mpindex")), "enpov-mpi-specs.csv")
specs_file <- here::here( "enpov-mpi-specs.csv")
mpi_specs <- define_mpi_specs( specs_file ,
  .poverty_cutoffs = c( 0.2, 1/3,  0.8),
  .uid = 'uuid',
  .aggregation = 'class' )
options(mpi_specs = mpi_specs)
# `.unit_of_analysis`, `.source_of_data`, and `.names_separator` are merely used for auto labels when generating the output later.

# mpi_specs[["indicators"]][["variable"]]

# household members
 # "nutrition"         "child_mortality"  "year_schooling"    "school_attendance" 

## household
#"cooking_fuel"      "sanitation"        "drinking_water"   
# "electricity"       "housing"           "assets" 

# Create an empty list to store deprivation profile for each indicator
deprivation_profile <- list()
```

```{r  table_specs_file, echo=F}
read.csv(specs_file) |> 
  gt::gt() |> 
  gt::tab_header(
    title = 'Global MPI – Dimensions, Indicators, Deprivation Cutoffs, and Weights'
  ) |> 
  gt::tab_options(
    table.width = '100%',
    table.font.size = 12,
  ) |> 
  gt::tab_footnote('Source: Alkire, S., Kanagaratnam, U. and Suppa, N. (2020). ‘The global Multidimensional Poverty Index (MPI): 2020 revision’, OPHI MPI Methodological Note 49, Oxford Poverty and Human Development Initiative, University of Oxford.')
```


# Deprivation Indicators 
    
```{r function-plot_indic}
#' plot_indic
#' 
#' Plotting functions to display indicators
#' 
#' @param indic the binary indicator vector
#' @param cross the crosstab variable vector
#' @param weight the weight vector
#' 
#' @import ggplot2
#' @import sjPlot
#' @import sjlabelled
#' @import unhcrthemes
#' @return a ggplot2 object
#' 

plot_indic <- function(indic, cross, weight){
  
  p <- sjPlot::plot_xtab(x= indic,
                  grp = cross,
                  type = "bar",
                  weight.by = weight,
                  # bar.pos = "stack",
                  # sort.frq =  "asc",
                  #show.ci = TRUE,
                  # wrap.labels = 40,
                  show.total = FALSE,
                  show.summary = FALSE,
                  show.prc = FALSE,
                  # summary.pos = "r",
                  coord.flip = TRUE) + 
  ## and the chart labels
  labs(title =  sjlabelled::get_label(indic),
       subtitle = paste0("By ",sjlabelled::get_label(cross) ),
       x = "",
       y = "",
       caption = "Source: ENPOVE 2022 inei.gob.pe microdatos"
      ) +
  ## Add UNHCR Theme
  unhcrthemes::theme_unhcr(font_size = 12,
                           # grid = "Y", axis = "X", axis_title = "y"
                           grid = "X",  axis = "Y",  axis_title = "X"
  ) 
  return(p)  
}
```


```{r function-plot_mpi}
#' plot_mpi
#' 
#' Plotting functions to display numeric value
#' 
#' @param indic the index vector
#' @param cross the crosstab variable vector
#' @param weight the weight vector
#' 
#' @import ggplot2
#' @import sjPlot
#' @import sjlabelled
#' @import unhcrthemes
#' @return a ggplot2 object
#' 

plot_mpi <- function(mpi, cross, weight){
  
  p <- sjPlot::plot_grpfrq(var.cnt = mpi,
                    var.grp = cross,
                    facet.grid = TRUE,
                    type = "bar",
                    weight.by = weight,
                    # bar.pos = "stack",
                    # sort.frq =  "asc",
                    #show.ci = TRUE,
                    # wrap.labels = 40,
                    #show.total = FALSE,
                    show.summary = FALSE,
                    show.prc = FALSE,
                    show.values = FALSE,
                    show.n = FALSE) + 
  ## and the chart labels
  labs(title =  sjlabelled::get_label(mpi),
       subtitle = paste0("By ",sjlabelled::get_label(cross) ),
       x = "",
       y = "",
       caption = "Source: ENPOVE 2022 inei.gob.pe microdatos"
  ) +
  ## Add UNHCR Theme
  unhcrthemes::theme_unhcr(font_size = 12,
                           # grid = "Y", axis = "X", axis_title = "y"
                           grid = "Y",  axis = "Y",  axis_title = "X"
  ) 
  return(p)  
}
```


# Household preprocessing ENPOVE 2022 

```{r  df_household_preprocessing}
##Preprocessing

#ENPOVE 2022
df_household <- read_sav(here::here("data-raw","ENPOVE2022_V_100 Características de la vivienda y del hogar.sav"))

#ENPOVE 2018
#df_household <- read_sav(here::here("data-raw","ENPOVE_Capitulo 100 - Carctaerísticas de la Vivienda y del Hogar.sav.sav"))

#ENAHO 2022
#df_household <- read_sav(here::here("data-raw","ENPOVE2022_V_100 Características de la vivienda y del hogar.sav"))

# names(df_household)
# df_household |> dplyr::select(CIUDAD) |> dplyr::distinct() |> dplyr::pull()

## Explore all content
#df_household |>  sjPlot::view_df()

df_householda <- df_household 

######## CREATE PCODE AT ADMIN 3 LEVEL. ONLY USED FOR ENPOVE 2022
df_household <- df_household  |>
  dplyr::mutate(CCDD = ifelse(nchar(CCDD) < 2, paste0("0", CCDD), CCDD))

df_household <- df_household  |>
  dplyr::mutate(CCPP = ifelse(nchar(CCPP) < 2, paste0("0", CCPP), CCPP))

df_household <- df_household  |>
  dplyr::mutate(CCDI = ifelse(nchar(CCDI) < 2, paste0("0", CCDI), CCDI))

df_household <- df_household  |>
  dplyr::mutate(Ubigeo = paste0(CCDD, CCPP, CCDI))


######## CREATE UNIQUE HOUSEHOLD ID
df_household <- df_household  |>
  dplyr::mutate(uuid = paste0(CONGLOMERADO, NSELV, NHOGAR))  |>
  dplyr::mutate(class = CIUDAD)


######## DEPURACIÓN DE FILAS 
#### Filtramos fuera del análisis las viviendas donde no vivían personas de Venezuela*.
df_household <- df_household  |>
  dplyr::filter(P15 == 1)
#### Borramos las filas donde la encuesta no llegó a su fin
df_household <- df_household  |>
  dplyr::filter(RESFIN <3)

```

# Household ENPOVE 2022

```{r  df_household_indicator}

##### Data Analysis ########################################
#  'Deprived' = 0, 'Not Deprived' = 1

######    DIMENSIÓN 3: SERVICIOS PÚBLICOS ####################

##### INDICADOR 1:PORCENTAJE DE HOGARES CON NECESIDADES DE AGUA

##Necesidad de agua = Hogares que no cuentan con acceso a agua a través de red pública dentro de la vivienda
# table(df_household$P108_1, useNA = "ifany")

df_household <- df_household |>
          dplyr::mutate(drinking_water = dplyr::case_when(
            P108_1 == 1 ~ 1,   TRUE ~ 0   ) )
df_household$drinking_water  <- labelled::labelled(df_household$drinking_water,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Living Standards | Drinking water")

# plot_indic(indic = df_household$drinking_water, 
#                        cross = df_household$class, 
#                        weight = df_household$factorfinal)
 
deprivation_profile$drinking_water <- df_household |>
  define_deprivation(
    .indicator = drinking_water,
    .cutoff = P108_1 == 1
  )

# ##Necesidad de agua = Hogares que no cuentan con acceso a agua a través de red pública
# df_household <- df_household |>
#           dplyr::mutate(drinking_waterv2 = dplyr::case_when(
#             P108_1 < 3 ~ 1,   TRUE ~ 0   ) )
# df_household$drinking_waterv2  <- labelled::labelled(df_household$drinking_waterv2,
#   labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
#   label = "INDICADOR 1:PORCENTAJE DE HOGARES CON NECESIDADES DE AGUA v2")


##### INDICADOR 2:PORCENTAJE DE HOGARES CON NECESIDADES DE SANEAMIENTO

##Necesidad de saneamiento = Hogares que no cuentan con conexión a desagüe dentro de la vivienda 
df_household <- df_household |>
          dplyr::mutate(sanitation = dplyr::case_when(
            P108_2 == 1 ~ 1,   TRUE ~ 0   ) )
df_household$sanitation  <- labelled::labelled(df_household$sanitation,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Living Standards |	Sanitation")


# plot_indic(indic = df_household$sanitation, 
#                        cross = df_household$class, 
#                        weight = df_household$factorfinal)

deprivation_profile$sanitation <- df_household |>
  define_deprivation(
    .indicator = sanitation,
    .cutoff = P108_2 == 1
  )

# ##Necesidad de saneamiento = Hogares que no cuentan con conexión a desagüe
# df_household <- df_household |>
#           dplyr::mutate(sanitationv2 = dplyr::case_when(
#             P108_2 < 3 ~ 1,   TRUE ~ 0   ) )
# df_household$sanitationv2  <- labelled::labelled(df_household$sanitationv2,
#   labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
#   label = "INDICADOR 2:PORCENTAJE DE HOGARES CON NECESIDADES DE SANEAMIENTO v2")


##### INDICADOR 3: PORCENTAJE DE HOGARES CON NECESIDADES DE ELECTRICIDAD

##Necesidad de electricidad = Hogares que no cuentan con acceso a alumbrado/electricidad
df_household <- df_household |>
          dplyr::mutate(electricity = dplyr::case_when(
            P108_3 == 1 ~ 1,   TRUE ~ 0   ) )
df_household$electricity  <- labelled::labelled(df_household$electricity,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Living Standards |	Electricity")


# plot_indic(indic = df_household$electricity, 
#                        cross = df_household$class, 
#                        weight = df_household$factorfinal)

deprivation_profile$electricity <- df_household |>
  define_deprivation(
    .indicator = electricity,
    .cutoff = P108_3 == 1
  )
 
#######    DIMENSIÓN 4: CONDICIONES DE VIVIENDA ####################

##### INDICADOR 1: ADEQUATE FLOORING

## Tipo de Piso## 
#unimproved floor when earth,sand,clay,mud, dung or other, as in UNHCR RMS indicator DWE02
# Se utilizó los hogares que tengan pisos de: 6) Tierra o 7) Otro material

df_household <- df_household |>
          dplyr::mutate(ind04_01 = dplyr::case_when(
            P104 %in% c(1:5) ~ 1,   TRUE ~ 0   ) )
df_household$ind04_01  <- labelled::labelled(df_household$ind04_01,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Adequate Flooring")


##### INDICADOR 2: ADEQUATE WALLS

## Tipo de Pared## 
#improved wall: cement,stone,bricks,cement blocks, covered adobe, wood planks, as in UNHCR RMS indicator DWE04. 
#Se utilizó los hogares que tengan paredes de: 4) Tapia; 5) Quincha (caña con barro); 6) Piedra con barro; 7) Madera (pona, tornillo, etc.); 8) Triplay/calamina/estera y 9) Otro material

df_household <- df_household |>
          dplyr::mutate(ind04_02 = dplyr::case_when(
            P102 %in% c(1:3) ~ 1,   TRUE ~ 0   ) )
df_household$ind04_02  <- labelled::labelled(df_household$ind04_02,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Adequate Walls")

## VERSION 2
#Se utilizó los hogares que tengan paredes de: 3) Adobe; 4) Tapia; 5) Quincha (caña con barro); 6) Piedra con barro; 7) Madera (pona, tornillo, etc.); 8) Triplay/calamina/estera y 9) Otro material

df_household <- df_household |>
          dplyr::mutate(ind04_02v2 = dplyr::case_when(
            P102 %in% c(1:2) ~ 1,   TRUE ~ 0   ) )
df_household$ind04_02v2  <- labelled::labelled(df_household$ind04_02v2,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Adequate Walls v2")

## VERSION 3
#Se utilizó los hogares que tengan paredes de: 2) Piedra, sillar con cal o cemento; 3) Adobe; 4) Tapia; 5) Quincha (caña con barro); 6) Piedra con barro; 7) Madera (pona, tornillo, etc.); 8) Triplay/calamina/estera y 9) Otro material

df_household <- df_household |>
          dplyr::mutate(ind04_02v3 = dplyr::case_when(
            P102 == 1 ~ 1,   TRUE ~ 0   ) )
df_household$ind04_02v3  <- labelled::labelled(df_household$ind04_02v3,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Adequate Walls v3")

##### INDICADOR 3: ADEQUATE ROOFS

## Tipo de Techo## 
#unimproved roof all options except metal, wood, ceramic tiles, cement, roofing shingles/sheets, as in UNHCR RMS indicator DWE03.
#Se utilizó los hogares que tengan techos de: 5) Caña o estera con torta de barro o cemento; 6) Triplay/estera/carrizo; 7) Paja, hojas de palmera, etc y 8) Otro material

df_household <- df_household |>
          dplyr::mutate(ind04_03 = dplyr::case_when(
            P103 %in% c(1:4) ~ 1,   TRUE ~ 0   ) )
df_household$ind04_03  <- labelled::labelled(df_household$ind04_03,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Adequate Roofs")

## VERSION 2
#Se utilizó los hogares que tengan techos de: 4) Planchas de calamina, fibra de cemento o similares; 5) Caña o estera con torta de barro o cemento; 6) Triplay/estera/carrizo; 7) Paja, hojas de palmera, etc y 8) Otro material
df_household <- df_household |>
          dplyr::mutate(ind04_03v2 = dplyr::case_when(
            P103 %in% c(1:3) ~ 1,   TRUE ~ 0   ) )
df_household$ind04_03v2  <- labelled::labelled(df_household$ind04_03v2,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Adequate Roofs v2")


## INDICADOR 4: HOUSING CONDITIONS. The household has inadequate housing materials in any of the three components: floor, roof, or walls.

df_household <- df_household |>
          dplyr::mutate(housing = dplyr::case_when(
            ind04_01 == 1 & ind04_02 == 1 & ind04_03 == 1 ~ 1,   
            TRUE ~ 0   ) )
df_household$housing  <- labelled::labelled(df_household$housing,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Living Standards | Adequate	Housing (floor, roof, walls)")


# plot_indic(indic = df_household$housing, 
#                        cross = df_household$class, 
#                        weight = df_household$factorfinal)

## VERSION 2
# df_household <- df_household |>
#           dplyr::mutate(housing = dplyr::case_when(
#             (ind04_01 ==1 | ind04_02v2 ==1 | ind04_03 ==1) ~ 1,   
#             TRUE ~ 0   ) )
# df_household$housing  <- labelled::labelled(df_household$housing,
#   labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
#   label = "Living Standards | Adequate	Housing (floor, roof, walls) v2")

## VERSION 3
# df_household <- df_household |>
#           dplyr::mutate(housing = dplyr::case_when(
#             (ind04_01 ==1 | ind04_02v2 ==1 | ind04_03v2 ==1) ~ 1,   
#             TRUE ~ 0   ) )
# df_household$housing  <- labelled::labelled(df_household$housing,
#   labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
#   label = "Living Standards | Adequate	Housing (floor, roof, walls) v3")

## VERSION 4
# df_household <- df_household |>
#           dplyr::mutate(housing = dplyr::case_when(
#             (ind04_01 ==1 | ind04_02v3 ==1 | ind04_03 ==1) ~ 1,   
#             TRUE ~ 0   ) )
# df_household$housing  <- labelled::labelled(df_household$housing,
#   labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
#   label = "Living Standards | Adequate	Housing (floor, roof, walls) v4")

## VERSION 5
# df_household <- df_household |>
#           dplyr::mutate(housing = dplyr::case_when(
#             (ind04_01 ==1 | ind04_02v3 ==1 | ind04_03v2 ==1) ~ 1,   
#             TRUE ~ 0   ) )
# df_household$housing  <- labelled::labelled(df_household$housing,
#   labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
#   label = "Living Standards | Adequate	Housing (floor, roof, walls) v5")

deprivation_profile$housing <- df_household |>
  define_deprivation(
    .indicator = housing,
    .cutoff = housing == 1
  )

##### INDICADOR 5: OVERCROWDING 

##Hacinamiento
# Calculate crowding index - overcrowded when more than 2.5 persons per room (using number of rooms in the Household (P105))
df_household <-  df_household  |>
  dplyr::mutate(crowding = P15_N/P105 )  |>
  dplyr::mutate(ind04_04 = dplyr::case_when( 
    crowding < 2.5 ~ 1, 
    TRUE ~ 0)
  )
df_household$ind04_04  <- labelled::labelled(df_household$ind04_04,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Sufficient Living space | Overcrowding")


# Calculate crowding index - overcrowded when more than 2.5 persons per room (using number of bedrooms in the Household (P106))
df_household <-  df_household  |>
  dplyr::mutate(P106vf = dplyr::case_when(
    P106 > 0 ~ P106, TRUE ~ P105))  |>
  dplyr::mutate(crowdingv2 = P15_N/P106vf
  )  |>
  dplyr::mutate(ind04_04v2 = dplyr::case_when(
    crowdingv2< 2.5 ~ 1, TRUE ~ 0)
  )

df_household$ind04_04v2  <- labelled::labelled(df_household$ind04_04v2,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Sufficient Living space | Overcrowding v2")


##### INDICADOR 6: COOKING FUEL

#The household cooks with dung, wood, charcoal or coal
df_household <- df_household |>
          dplyr::mutate(cooking_fuel = dplyr::case_when(
            P109 %in% c(1:3) ~ 1,   TRUE ~ 0   ) )
df_household$cooking_fuel  <- labelled::labelled(df_household$cooking_fuel,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Living Standards |	Cooking fuel")


# plot_indic(indic = df_household$cooking_fuel, 
#                        cross = df_household$class, 
#                        weight = df_household$factorfinal)

deprivation_profile$cooking_fuel <- df_household |>
  define_deprivation(
    .indicator = cooking_fuel,
    .cutoff = P109 < 3
  )

##### INDICADOR 7: ASSETS

#The household does not own a car or truck and does not own more than one of the following assets: radio, television, telephone, computer, animal cart, bicycle, motorbike or refrigerator

#Adaptamos el cálculo de este indicador. Si los hogares no tienen más de uno de los siguientes activos: 1) Radio, 2) TV, 6) Teleofono celular or 7) Telefono fijo, 5) Computadora/laptop/tableta, 9) Refrigeradora/congeladora

# PREPROCESSING
df_household <- df_household  |>
  dplyr::mutate(P110_1 = ifelse(P110_1==2,0,P110_1)) |>
  dplyr::mutate(P110_2 = ifelse(P110_2==2,0,P110_2)) |>
  dplyr::mutate(P110_3 = ifelse(P110_3==2,0,P110_3)) |>
  dplyr::mutate(P110_4 = ifelse(P110_4==2,0,P110_4)) |>
  dplyr::mutate(P110_5 = ifelse(P110_5==2,0,P110_5)) |>
  dplyr::mutate(P110_6 = ifelse(P110_6==2,0,P110_6)) |>
  dplyr::mutate(P110_7 = ifelse(P110_7==2,0,P110_7)) |>
  dplyr::mutate(P110_8 = ifelse(P110_8==2,0,P110_8)) |>
  dplyr::mutate(P110_9 = ifelse(P110_9==2,0,P110_9)) |>
  dplyr::mutate(P110_10 = ifelse(P110_10==2,0,P110_10)) |>
  dplyr::mutate(P110_11 = ifelse(P110_11==2,0,P110_11)) |>
  dplyr::mutate(P110_12 = ifelse(P110_12==2,0,P110_12)) |>
  dplyr::mutate(P110_13 = ifelse(P110_13==2,0,P110_13))

# Creación de variable tenencia de algún tipo de teléfono (fijo o móvil)
df_household <- df_household |>
          dplyr::mutate(P110_14 = dplyr::case_when(
            P110_6 == 1 | P110_7 == 1 ~ 1,   TRUE ~ 0   ) )

# Creación de un indicador compuesto que resume la tenencia de: 1) TV; 5) Computadora / laptop / tableta; 14) Teléfono (fijo o móvil); 8) Radio; 9) Refrigeradora/congeladora
df_household <- df_household  |>
  dplyr::mutate(P110 = P110_1 + P110_5 + P110_14 + P110_8 + P110_9)

#Household does not owns 3 or more items
df_household <- df_household |>
          dplyr::mutate(assets = dplyr::case_when(
            P110 > 2 ~ 1,   TRUE ~ 0   ) )
df_household$assets  <- labelled::labelled(df_household$assets,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Living Standards |	Assets (does not owns 3 or more esential items)") 


# plot_indic(indic = df_household$assets, 
#                        cross = df_household$class, 
#                        weight = df_household$factorfinal)

deprivation_profile$assets <- df_household |>
  define_deprivation(
    .indicator = assets,
    .cutoff = P110 <=2
  )

#Household does not owns 2 or more items
df_household <- df_household |>
          dplyr::mutate(assetsv2 = dplyr::case_when(
            P110 > 3 ~ 1,   TRUE ~ 0   ) )
df_household$assetsv2  <- labelled::labelled(df_household$assetsv2,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Living Standards |	Assets (does not owns 2 or more items)") 


# plot_indic(indic = df_household$assetsv2, 
#                        cross = df_household$class, 
#                        weight = df_household$factorfinal)

##### INDICADOR 8: TIPO DE VIVIENDA

## Tipo de vivienda## 
#Only apartment and house, as in UNHCR RMS indicator DWE01
#Se utilizó los hogares cuyo tipo de vivienda no sean: 1) Casa independiente o 2) Departamento en edificio
df_household <- df_household |>
          dplyr::mutate(ind04_07 = dplyr::case_when(
            P101 %in% c(1:2) ~ 1,   TRUE ~ 0   ) )
df_household$ind04_07  <- labelled::labelled(df_household$ind04_07,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Acceptable Accomodation type") 

# 
# plot_indic(indic = df_household$ind04_07, 
#                        cross = df_household$class, 
#                        weight = df_household$factorfinal)

```



```{r HogarViz}

cross <- c("CIUDAD")
crosslab <- "CIUDAD"
# dput(names(df_household))
data <- df_household |>
        dplyr::select(CIUDAD, factorfinal , 
#                        P21, 
# P101, P102, P103, P104, P105, P106, P107, P108_1, 
# P108_2, P108_3, P108_4, P109, P110_1, P110_2, P110_3, 
# P110_4, P110_5, P110_6, P110_7, P110_8, P110_9, P110_10, 
# P110_11, P110_12, P110_13, P111, P111A, P112_1, P112_2, 
# P112_3, P112_4, P112_5, P112_6, P112_7, P112_8
SEGMENTO,  Ubigeo,   uuid,
drinking_water,  #drinking_waterv2, 
sanitation,  #sanitationv2,
electricity,
#ind04_01,  
#ind04_02,  #ind04_02v2, #ind04_02v3, 
#ind04_03,  #ind04_03v2, 
housing,
#crowding,  
ind04_04,  ind04_04v2,  
#P106vf, crowdingv2, ind04_04v2, 
cooking_fuel, # P110_14, # P110,        
assets,  assetsv2, 
#ind04_07
ind04_07
)
# retrieve value and variable labels
#data.var <- sjlabelled::get_label(data)
data.val <-sjlabelled::get_labels(data)
weight <- as.vector(data$factorfinal)

for (i in 6:ncol(data)) {
  # i <-5
  var <- names(data)[i]
  varlab <- sjlabelled::get_label(data[i])
  type <- ifelse(lengths(data.val[i]) > 0, 
                 paste0(" -- Categoric Variable"), 
                 paste0(" -- Numeric Variable"))
  #cat(paste0(i, "-", var, "-" ,varlab,"-" ,type,"\n\n"))
  t <- as.data.frame(table(data[ , i] ))
  if(nrow(t)>1 ) {
    ## test if it is numeric or categoric variable
    if(lengths(data.val[i]) > 0) {
      # if(nrow(t)< 8) {
      p <-   sjPlot::plot_xtab(x= data[[i]],
                               grp = data[[cross]],
                               type = "bar",
                               weight.by = weight,
                               # bar.pos = "stack",
                              # sort.frq =  "asc",
                               #show.ci = TRUE,
                               wrap.labels = 40,
                               show.total = FALSE,
                               show.summary = FALSE,
                               show.prc = FALSE,
                               summary.pos = "r",
                               coord.flip = TRUE) +
        
        unhcrthemes::theme_unhcr(font_size = 12,
                                # grid = "Y", axis = "X", axis_title = "y"
                                  grid = "X",  axis = "Y",  axis_title = "X"
                                 ) + 
        ## and the chart labels
        labs(title = stringr::str_wrap(paste0(varlab) , 70),
             subtitle = paste0("Cruzado con ", crosslab),
             x = "",
             y = "",
             caption = "Fuente:  ENPOVE, https://proyectos.inei.gob.pe/microdatos/")
    } else {
      
      
      ## Print an histogram
      p <-   sjPlot::plot_grpfrq(var.cnt = data[[i]],
                                 var.grp = data[[cross]],
                                 type = "bar",
                                 weight.by = weight,
                                 # sort.frq =  "asc",
                                 # bar.pos = "stack",
                                 wrap.labels = 40,
                                 show.summary = FALSE,
                                 show.prc = FALSE,
                                 show.values = FALSE,
                                 show.n = FALSE) +
        
        unhcrthemes::theme_unhcr(font_size = 12,
                                 grid = "Y", 
                                 axis = "X", 
                                 axis_title = FALSE) + 
        ## and the chart labels
        labs(title = stringr::str_wrap(paste0(varlab) , 70),
             subtitle = paste0("Cruzado con ",crosslab),
             x = "",
             y = "",
             caption = "Fuente: ENPOVE, https://proyectos.inei.gob.pe/microdatos/")
    }
    print(p)
    #ggsave( paste0("plot/",cross," - ", i, "-",var, ".png"),  plot =  p, device = "png", width = 24, height = 16, units = "cm")
  } else {
    cat(paste0("Un solo valor para ", var, "\n"))
  }
}

```
 
# Household roster preprocessing ENPOVE 2022 

```{r df_household_roster_preprocessing, echo=FALSE, cache=FALSE}

df_household_roster <- read_sav(here::here("data-raw","ENPOVE2022_V_200-300-400-500-600-700-800.sav"))
#df_household_roster |>  sjPlot::view_df()
df_household_rostera <- df_household_roster

######## CONSTRUIR VARIABLE UBIGEO
df_household_roster <- df_household_roster  |>
  dplyr::mutate(CCDD = ifelse(nchar(CCDD) < 2, paste0("0", CCDD), CCDD))

df_household_roster <- df_household_roster  |>
  dplyr::mutate(CCPP = ifelse(nchar(CCPP) < 2, paste0("0", CCPP), CCPP))

df_household_roster <- df_household_roster  |>
  dplyr::mutate(CCDI = ifelse(nchar(CCDI) < 2, paste0("0", CCDI), CCDI))

df_household_roster <- df_household_roster  |>
  dplyr::mutate(Ubigeo = paste0(CCDD, CCPP, CCDI))


######## CONSTRUIR UN ID PARA HOGARES
df_household_roster <- df_household_roster  |>
  dplyr::mutate(uuid = paste0(CONGLOMERADO, NSELV, NHOGAR))|>
  dplyr::mutate(class = CIUDAD)

######## CONSTRUIR UN ID PARA PERSONAS
df_household_roster <- df_household_roster  |>
  dplyr::mutate(id_persona = paste0(uuid, P200_N))

######## DEPURACIÓN DE FILAS 
#### Filtramos fuera del análisis las viviendas donde no vivían personas de Venezuela*.
df_household_roster <- df_household_roster  |>
  filter(P15 ==1)

#### Borramos las filas donde la encuesta no llegó a su fin
df_household_roster <- df_household_roster  |>
  filter(RESFIN <3)

#### Filtramos fuera del análisis las personas que no migraron de Venezuela*.
df_household_roster <- df_household_roster  |>
  filter(P208 ==1)

```


# Household roster ENPOVE 2022

```{r df_household_roster, echo=FALSE, cache = FALSE}

#### Data Analysis ########################################
# 0: Hay necesidad
# 1: No hay necesidad/vulnerabilidad

###############    DIMENSIÓN 1: SALUD ####################

##### INDICADOR 1: Afiliación a seguro de salud
df_household_roster <- df_household_roster |>
          dplyr::mutate(nutrition = dplyr::case_when(
            is.na(P401_5) | P401_5 == 0 ~ 1,   TRUE ~ 0   ) )
df_household_roster$nutrition  <- labelled::labelled(df_household_roster$nutrition,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Health | Nutrition")


# plot_indic(indic = df_household_roster$nutrition, 
#                        cross = df_household_roster$class, 
#                        weight = df_household_roster$factorfinal)

## Get deprivation
deprivation_profile$nutrition <- df_household_roster |>
  define_deprivation(
    .indicator = nutrition,
    .cutoff = P401_5 == 0,
    .collapse = TRUE
  )

##### INDICADOR 2: Access to health care services when needed (en el último mes) P405<7 & P406>4

# Creción de variable de apoyo
df_household_roster <- df_household_roster |>
          dplyr::mutate(P406 = dplyr::case_when(
            P406_1 == 1 | P406_2 == 1 |
            P406_3 == 1 | P406_4 == 1 | 
            P405_7 == 1 | is.na(P405_7) ~ 1,   
            TRUE ~ 0   ) )

df_household_roster <- df_household_roster |>
          dplyr::mutate(child_mortality = dplyr::case_when(
            P406 == 1 ~ 1,   TRUE ~ 0   ) )
df_household_roster$child_mortality  <- labelled::labelled(df_household_roster$child_mortality,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Health |	Child mortality")

# plot_indic(indic = df_household_roster$child_mortality, 
#                        cross = df_household_roster$class, 
#                        weight = df_household_roster$factorfinal)


deprivation_profile$child_mortality <- df_household_roster |>
  define_deprivation(
    .indicator = child_mortality,
    .cutoff = P406 == 0 ,
    .collapse = TRUE
  )

## crear sum de indicadores, hay manera más eficaz de hacerlo??

df_household_roster1 <- df_household_roster  |>
  group_by(uuid)  |>
  summarise(sum_nutrition = sum(nutrition, na.rm = TRUE ))

df_household_roster2 <- df_household_roster  |>
  group_by(uuid)  |>
  summarise(sum_child_mortality = sum(child_mortality, na.rm = TRUE ))

df_household_roster <- merge(df_household_roster, df_household_roster1, by = "uuid")
df_household_roster <- merge(df_household_roster, df_household_roster2, by = "uuid")

df_household_roster<- df_household_roster  |>
  group_by(uuid)  |>
  dplyr::mutate(nutrition_vf = sum_nutrition / n())  |>
  dplyr::mutate(child_mortality_vf = sum_child_mortality / n())


##################    DIMENSIÓN 2: EDUCACIÓN ####################

##### INDICADOR 1: Personas de 18 a más años de edad tienen último nivel de estudios Educación Media Diversificada Completa/Secundaria completa
#P205 > 17 & ((P501 | P501B)  < 6

df_household_roster <- df_household_roster |>
          dplyr::mutate(year_schooling = dplyr::case_when(
            (P205_A < 18 | is.na(P205_A)) |
            (P205_A > 17 & (P501 %in% c(6:11) | P501B %in% c(6:12))) 
            ~ 1, TRUE ~ 0   ) )

df_household_roster$year_schooling  <- labelled::labelled(df_household_roster$year_schooling,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Education  |	Years of schooling")
#  label = "INDICADOR 11: Escolaridad en adultos del hogar (Mayores de edad cuyo nivel educativo es igual o superior a secundaria completa) ")


# plot_indic(indic = df_household_roster$year_schooling, 
#                        cross = df_household_roster$class, 
#                        weight = df_household_roster$factorfinal)


deprivation_profile$year_schooling <- df_household_roster |>
  define_deprivation(
    .indicator = year_schooling,
    .cutoff = year_schooling == 0,
    .collapse = TRUE
  )

##### INDICADOR 2: Asistencia a la escuela P205 < 18 & no asiste
df_household_roster <- df_household_roster |>
          dplyr::mutate(school_attendance = dplyr::case_when(
            (P205_A > 18 | is.na(P205_A)) | 
            (P205_A > 2 & P205_A < 18 & P506 == 1) ~ 1,   TRUE ~ 0   ) )
df_household_roster$school_attendance  <- labelled::labelled(df_household_roster$school_attendance,
  labels = c( 'Deprived' = 0, 'Not Deprived' = 1 ),
  label = "Education  |	School attendance")
  #label = "INDICADOR 12: Escolaridad infantil (NNA entre 3 y 18 años matriculados en la escuela")


# plot_indic(indic = df_household_roster$school_attendance, 
#                        cross = df_household_roster$class, 
#                        weight = df_household_roster$factorfinal)

deprivation_profile$school_attendance <- df_household_roster |>
  define_deprivation(
    .indicator = school_attendance,
    .cutoff = school_attendance == 0,
    .collapse = TRUE
  )

## crear sum de indicadores, hay manera más eficaz de hacerlo??
# 
# df_household_roster3 <- df_household_roster  |>
#   group_by(uuid)  |>
#   summarise(sum_year_schooling = sum(year_schooling,na.rm = TRUE ))
# 
# df_household_roster4 <- df_household_roster  |>
#   group_by(uuid)  |>
#   summarise(sum_school_attendance = sum(school_attendance,na.rm = TRUE ))
# 
# df_household_roster <- merge(df_household_roster, df_household_roster3, by = "uuid")
# df_household_roster <- merge(df_household_roster, df_household_roster4, by = "uuid")
# 
# df_household_roster<- df_household_roster  |>
#   group_by(uuid)  |>
#   dplyr::mutate(year_schooling_vf = sum_year_schooling / n())  |>
#   dplyr::mutate(school_attendance_vf = sum_school_attendance / n())
# 
# 
# ################    DIMENSIÓN 0: POBREZA MONETARIA ####################
# ## crear ubigeo del lugar de trabajo
# df_household_roster$P625A_COD_DEPA <- as.character(df_household_roster$P625A_COD_DEPA)
# df_household_roster$P625_COD_PROV <- as.character(df_household_roster$P625_COD_PROV)
# df_household_roster$P625_COD_DIST <- as.character(df_household_roster$P625_COD_DIST)
# 
# df_household_roster <- df_household_roster  |>
#   dplyr::mutate(P625A_COD_DEPA = ifelse(nchar(P625A_COD_DEPA) < 2, paste0("0", P625A_COD_DEPA), P625A_COD_DEPA))
# 
# df_household_roster <- df_household_roster  |>
#   dplyr::mutate(P625_COD_PROV = ifelse(nchar(P625_COD_PROV) < 2, paste0("0", P625_COD_PROV), P625_COD_PROV))
# 
# df_household_roster <- df_household_roster  |>
#   dplyr::mutate(P625_COD_DIST = ifelse(nchar(P625_COD_DIST) < 2, paste0("0", P625_COD_DIST), P625_COD_DIST))
# 
# df_household_roster <- df_household_roster  |>
#   dplyr::mutate(Ubigeo_Trabajo = dplyr::case_when(
#     P625==1 ~ Ubigeo,
#     P625==2 ~ paste0(P625A_COD_DEPA, P625_COD_PROV, P625_COD_DIST))
#     )
# 
# ## crear promedio de horas trabajadas
# df_household_roster$P625A_COD_DEPA <- as.character(df_household_roster$P615_T)
# df_household_roster$P625_COD_PROV <- as.character(df_household_roster$P616)
# df_household_roster$P625_COD_PROV <- as.character(df_household_roster$P616A)
# 
# df_household_roster <- df_household_roster  |>
#   dplyr::mutate(HORAS_TRABAJADAS_PROMEDIO = dplyr::case_when(
#     P616==1 ~ P615_T,
#     P616==2 ~ P616A)
#     ) 
# 
# ########## SCRIPT INGRESO TOTAL
# ## INGRESO EN DINERO 
# df_household_roster <- df_household_roster  |>
#   dplyr::mutate(M622_1 = dplyr::case_when(
#     P621==1 ~ P622_1*30,
#     P621==2 ~ P622_1*4.33,
#     P621==3 ~ P622_1*2,
#     P621==4 ~ P622_1*1,
#     TRUE ~ 0)
#     ) 
# 
# ## INGRESO EN ESPECIE
# df_household_roster <- df_household_roster  |>
#   dplyr::mutate(M622_2 = dplyr::case_when(
#     P621==1 ~ P622_2*30,
#     P621==2 ~ P622_2*4.33,
#     P621==3 ~ P622_2*2,
#     P621==4 ~ P622_2*1,
#     TRUE ~ 0)
#     )  
#   
# df_household_roster$P623_1 <- as.numeric(df_household_roster$P623_1)
# df_household_roster$P623_2 <- as.numeric(df_household_roster$P623_2)
# df_household_roster$P624_1 <- as.numeric(df_household_roster$P624_1)
# df_household_roster$P624_2 <- as.numeric(df_household_roster$P624_2)
# 
# ## crear ingreso total  
# df_household_roster$INGTOT <- df_household_roster$M622_1 +
#                     df_household_roster$M622_2 + 
#                     df_household_roster$P623_1 + 
#                     df_household_roster$P623_2 + 
#                     df_household_roster$P624_1 + 
#                    df_household_roster$P624_2
# 
# ## crear ingreso total monetario
# df_household_roster$INGTOT_MONETARIO <- df_household_roster$M622_1 + df_household_roster$P623_1 + df_household_roster$P624_1 
# #summary(df_household_roster$INGTOT_MONETARIO)
# 
# ## crear ingreso total no monetario
# df_household_roster$INGTOT_NO_MONETARIO <- df_household_roster$M622_2 + df_household_roster$P623_2 + df_household_roster$P624_2
# #summary(df_household_roster$INGTOT_NO_MONETARIO)
# 
# 
# ################## Pobreza #########################
# ## generar variable Ingreso_medio_persona1 (INGTOT) + Ingreso_medio_persona2 (INGTOT Monetario)
# ## (INGTOT of household, divided by household members)
# ## en muchos casos solo hay 1 ingreso en cada hogar (los demás miembros realmente no trabajan o no llenaron el cuestionario??)
# 
# # Ingreso Household1 (INGTOT)
# 
# df_household_roster$Ingreso_hogar1 <-  ave(df_household_roster$INGTOT, df_household_roster$uuid, FUN=sum)
# 
# # Ingreso Household2 (INGTOT_Monetario)
# 
# df_household_roster$Ingreso_hogar2 <-  ave(df_household_roster$INGTOT_MONETARIO, df_household_roster$uuid, FUN=sum)
# 
# # Ingreso_medio_persona1  
# 
# df_household_roster$NSELV <- as.numeric(df_household_roster$NSELV)
# 
# df_household_roster <- df_household_roster  |>
#   group_by(NSELV)  |>
#   dplyr::mutate(N_Personas_Hogar = n())
# 
# df_household_roster$Ingreso_Medio_Persona1 <- df_household_roster$Ingreso_hogar1/df_household_roster$N_Personas_Hogar
# 
# # Ingreso_medio_persona2  
# 
# df_household_roster$Ingreso_Medio_Persona2 <- df_household_roster$Ingreso_hogar2/df_household_roster$N_Personas_Hogar

#################### Personas debajo linea de Pobreza 2021

# INGTOT
# 
# df_household_roster$personas_debajo_linea_pobreza_2021 <- NA; 
# df_household_roster[df_household_roster$Ingreso_Medio_Persona1 <= 378, 
#           "personas_debajo_linea_pobreza_2021"] <- 1                             
# df_household_roster$personas_debajo_linea_pobreza_2021[is.na(df_household_roster$personas_debajo_linea_pobreza_2021)] <- 2
# unique(df_household_roster[,'personas_debajo_linea_pobreza_2021'])
# 
# df_household_roster  |> 
#   group_by(personas_debajo_linea_pobreza_2021)  |> 
#   count(personas_debajo_linea_pobreza_2021)
# 
# # ING Monetario
# 
# df_household_roster$personas_debajo_linea_pobreza_2021_2 <- NA; 
# df_household_roster[df_household_roster$Ingreso_Medio_Persona2 <= 378, "personas_debajo_linea_pobreza_2021_2"] <- 1                             
# df_household_roster$personas_debajo_linea_pobreza_2021_2[is.na(df_household_roster$personas_debajo_linea_pobreza_2021_2)] <- 2
# unique(df_household_roster[,'personas_debajo_linea_pobreza_2021_2'])
# 
# ################# Personas debajo linea de Pobreza 2022
# 
# # INGTOT
# df_household_roster$personas_debajo_linea_pobreza_2022 <- NA; 
# df_household_roster[df_household_roster$Ingreso_Medio_Persona1 <= 418.5, "personas_debajo_linea_pobreza_2022"] <- 1                             
# df_household_roster$personas_debajo_linea_pobreza_2022[is.na(df_household_roster$personas_debajo_linea_pobreza_2022)] <- 2
# unique(df_household_roster[,'personas_debajo_linea_pobreza_2022'])
# 
# df_household_roster  |> 
#   group_by(personas_debajo_linea_pobreza_2022)  |> 
#   count(personas_debajo_linea_pobreza_2022)
# 
# 
# # ING Monetario
# 
# df_household_roster$personas_debajo_linea_pobreza_2022_2 <- NA; 
# df_household_roster[df_household_roster$Ingreso_Medio_Persona2 <= 418.5, "personas_debajo_linea_pobreza_2022_2"] <- 1                             
# df_household_roster$personas_debajo_linea_pobreza_2022_2[is.na(df_household_roster$personas_debajo_linea_pobreza_2022_2)] <- 2
# unique(df_household_roster[,'personas_debajo_linea_pobreza_2022_2'])
# 
# 
# 
# #################### Personas debajo linea de Pobreza extrema 2021
# 
# # INGTOT
# 
# df_household_roster$personas_debajo_linea_pobreza_extrema_2021 <- NA; 
# df_household_roster[df_household_roster$Ingreso_Medio_Persona1 <= 201, "personas_debajo_linea_pobreza_extrema_2021"] <- 1                             
# df_household_roster$personas_debajo_linea_pobreza_extrema_2021[is.na(df_household_roster$personas_debajo_linea_pobreza_extrema_2021)] <- 2
# unique(df_household_roster[,'personas_debajo_linea_pobreza_extrema_2021'])
# 
# df_household_roster  |> 
#   group_by(personas_debajo_linea_pobreza_extrema_2021)  |> 
#   count(personas_debajo_linea_pobreza_extrema_2021)
# 
# # ING Monetario
# 
# df_household_roster$personas_debajo_linea_pobreza_extrema_2021_2 <- NA; 
# df_household_roster[df_household_roster$Ingreso_Medio_Persona2 <= 378, "personas_debajo_linea_pobreza_extrema_2021_2"] <- 1                             
# df_household_roster$personas_debajo_linea_pobreza_extrema_2021_2[is.na(df_household_roster$personas_debajo_linea_pobreza_extrema_2021_2)] <- 2
# unique(df_household_roster[,'personas_debajo_linea_pobreza_extrema_2021_2'])
# 

################# Personas debajo linea de Pobreza 2022

# INGTOT
# 
# df_household_roster$personas_debajo_linea_pobreza_extrema_2022 <- NA; 
# df_household_roster[df_household_roster$Ingreso_Medio_Persona1 <= 222.5, "personas_debajo_linea_pobreza_extrema_2022"] <- 1                             
# df_household_roster$personas_debajo_linea_pobreza_extrema_2022[is.na(df_household_roster$personas_debajo_linea_pobreza_extrema_2022)] <- 2
# unique(df_household_roster[,'personas_debajo_linea_pobreza_extrema_2022'])
# 
# df_household_roster  |> 
#   group_by(personas_debajo_linea_pobreza_extrema_2022)  |> 
#   count(personas_debajo_linea_pobreza_extrema_2022)
# 
# # ING Monetario
# 
# df_household_roster$personas_debajo_linea_pobreza_extrema_2022_2 <- NA; 
# df_household_roster[df_household_roster$Ingreso_Medio_Persona2 <= 222.5, "personas_debajo_linea_pobreza_extrema_2022_2"] <- 1                             
# df_household_roster$personas_debajo_linea_pobreza_extrema_2022_2[is.na(df_household_roster$personas_debajo_linea_pobreza_extrema_2022_2)] <- 2
# unique(df_household_roster[,'personas_debajo_linea_pobreza_extrema_2022_2'])
# 
#  
# 
# ####Select variables####
# df_household_roster_final <-  df_household_roster  |> 
#   select(uuid, CCDD,DEPARTAMENTO,CCPP,PROVINCIA,CCDI,DISTRITO,CIUDAD,CONGLOMERADO,NSELV,VIVIENDA,THOGAR,NHOGAR,ESTRATO,VRESFIN,RESFIN,P15,P15_N,
#          INF_200,P200_N,P203,P204,P205_A,P205_B,P206,P207_1,P208,P401_1,P401_2,P401_3,P401_4,P401_5,P405_1,P405_2,P405_3,P405_4,P405_5,P405_6,P405_7,
#          P406_1,P406_2,P406_3,P406_4,P406_5,P406_6,P406_7,P406_8,P501,P501B,P506,P621,P622_1,P622_2,P623_1,P623_2,P623_3,P624_1,P624_2,P624_3,P624_4,
#          factorfinal,Ubigeo,id_persona,nutrition,P406,child_mortality,sum_nutrition,sum_child_mortality,nutrition_vf,child_mortality_vf,year_schooling,school_attendance,sum_year_schooling,sum_school_attendance,year_schooling_vf,school_attendance_vf,
#          Ubigeo_Trabajo,HORAS_TRABAJADAS_PROMEDIO,M622_1,M622_2,INGTOT,INGTOT_MONETARIO,INGTOT_NO_MONETARIO,Ingreso_hogar1,Ingreso_hogar2,N_Personas_Hogar,
#          Ingreso_Medio_Persona1,Ingreso_Medio_Persona2)

```



```{r HogarRostViz}
# dput(names(df_household))
data_roster <- df_household_roster |>
        dplyr::select( CIUDAD, factorfinal , uuid,
                       nutrition, child_mortality, year_schooling, school_attendance

)
# retrieve value and variable labels
#data_roster.var <- sjlabelled::get_label(data_roster)
data_roster.val <-sjlabelled::get_labels(data_roster)
weight <- as.vector(data_roster$factorfinal)

for (i in 4:ncol(data_roster)) {
  # i <-5
  var <- names(data_roster)[i]
  varlab <- sjlabelled::get_label(data_roster[i])
  type <- ifelse(lengths(data_roster.val[i]) > 0, 
                 paste0(" -- Categoric Variable"), 
                 paste0(" -- Numeric Variable"))
  #cat(paste0(i, "-", var, "-" ,varlab,"-" ,type,"\n\n"))
  t <- as.data.frame(table(data_roster[ , i] ))
  if(nrow(t)>1 ) {
    ## test if it is numeric or categoric variable
    if(lengths(data_roster.val[i]) > 0) {
      # if(nrow(t)< 8) {
      p <-   sjPlot::plot_xtab(x= data_roster[[i]],
                               grp = data_roster[[cross]],
                               type = "bar",
                               weight.by = weight,
                               # bar.pos = "stack",
                              # sort.frq =  "asc",
                               #show.ci = TRUE,
                               wrap.labels = 40,
                               show.total = FALSE,
                               show.summary = FALSE,
                               show.prc = FALSE,
                               summary.pos = "r",
                               coord.flip = TRUE) +
        
        unhcrthemes::theme_unhcr(font_size = 12,
                                # grid = "Y", axis = "X", axis_title = "y"
                                  grid = "X",  axis = "Y",  axis_title = "X"
                                 ) + 
        ## and the chart labels
        labs(title = stringr::str_wrap(paste0(varlab) , 70),
             subtitle = paste0("Cruzado con ", crosslab),
             x = "",
             y = "",
             caption = "Fuente:  ENPOVE, https://proyectos.inei.gob.pe/microdatos/")
    } else {
      
      
      ## Print an histogram
      p <-   sjPlot::plot_grpfrq(var.cnt = data_roster[[i]],
                                 var.grp = data_roster[[cross]],
                                 type = "bar",
                                 weight.by = weight,
                                 # sort.frq =  "asc",
                                 # bar.pos = "stack",
                                 wrap.labels = 40,
                                 show.summary = FALSE,
                                 show.prc = FALSE,
                                 show.values = FALSE,
                                 show.n = FALSE) +
        
        unhcrthemes::theme_unhcr(font_size = 12,
                                 grid = "Y", 
                                 axis = "X", 
                                 axis_title = FALSE) + 
        ## and the chart labels
        labs(title = stringr::str_wrap(paste0(varlab) , 70),
             subtitle = paste0("Cruzado con ",crosslab),
             x = "",
             y = "",
             caption = "Fuente: ENPOVE, https://proyectos.inei.gob.pe/microdatos/")
    }
    print(p)
    #ggsave( paste0("plot/",cross," - ", i, "-",var, ".png"),  plot =  p, device = "png", width = 24, height = 16, units = "cm")
  } else {
    cat(paste0("Un solo valor para ", var, "\n"))
  }
}

```


# Multidimensional Poverty Index


```{r}
# ----------------------------------
# Compute the MPI
mpi_result <- df_household |>
  compute_mpi(deprivation_profile)

# #mpi_result_enpove2018 <- df_household |>
#   compute_mpi(deprivation_profile)
# 
# #mpi_result_enaho2022 <- df_household |>
#   compute_mpi(deprivation_profile)

# The terms "censored" and "uncensored" in the context of the Multidimensional Poverty Index (MPI) refer to different approaches in handling missing or incomplete data when calculating poverty measures.
# ## Censored Headcount Ratio
# 
# The censored headcount ratio considers only those individuals for whom data is available for all the dimensions included in the MPI. If an individual is missing data for any of the dimensions, they are excluded from the calculation. This method may underestimate the true extent of poverty if it leaves out individuals who are likely to be deprived but lack complete data.
# 
# 
# ## Uncensored Headcount Ratio
# 
# In contrast, the uncensored headcount ratio considers all individuals, regardless of whether data is missing for some dimensions. It provides a more inclusive measure, incorporating individuals with incomplete data and assuming they are not deprived in the dimensions for which data is missing. This approach may overestimate poverty if the missing data is associated with deprivation.
# 
# ## Censored Deprivation Matrix
# 
# The censored deprivation matrix is a matrix that represents the extent of deprivation for individuals with complete data across all dimensions. It typically consists of binary values indicating whether an individual is deprived or not in each dimension.
# 
# 
# ## Uncensored Deprivation Matrix
# 
# The uncensored deprivation matrix, on the other hand, includes individuals with incomplete data and assumes they are not deprived in dimensions with missing information. This matrix may include imputed or estimated values for missing data to calculate a more comprehensive poverty measure.
# 
# The choice between censored and uncensored approaches depends on the availability and quality of data. While the censored approach provides a more conservative estimate by excluding individuals with missing data, the uncensored approach aims for inclusivity but relies on assumptions about the missing information. Researchers and policymakers should carefully consider the implications of each approach based on the specific context and data characteristics.
### Now appending to the previous frame and labeling
#mpi_headcount_ratio_uncensored <- mpi_result[["headcount_ratio"]][["uncensored"]] 
#mpi_headcount_ratio_censored <- mpi_result[["headcount_ratio"]][["censored"]]
mpi_deprivation_matrix_uncensored <- mpi_result[["deprivation_matrix"]][["uncensored"]] |> janitor::clean_names()
mpi_deprivation_matrix_k_20 <- mpi_result[["deprivation_matrix"]][["k_20"]] |> janitor::clean_names()
mpi_deprivation_matrix_k_33 <- mpi_result[["deprivation_matrix"]][["k_33"]] |> janitor::clean_names()
mpi_deprivation_matrix_k_80 <- mpi_result[["deprivation_matrix"]][["k_80"]] |> janitor::clean_names()

#names(mpi_deprivation_matrix_uncensored)

#mpi_deprivation_matrix_censored <- mpi_result[["deprivation_matrix"]][["censored"]] 

df_household <- df_household |>
  dplyr::left_join( mpi_deprivation_matrix_uncensored |> dplyr::select(uuid, deprivation_score ), by = c("uuid"))
## Index but not weighted
# mpi_result$index

df_household$deprivation_score  <- labelled::labelled(df_household$deprivation_score,
  label = "Deprivation Score")


plot_mpi(mpi = df_household$deprivation_score, 
        cross = df_household$class, 
        weight = df_household$factorfinal)

```


#Household preprocessing ENPOVE 2018
 
```{r df_household_preprocessing_enpove_2018}
##Preprocessing

#ENPOVE 2018
df_household <- read_sav(here::here("data-raw","ENPOVE_Capitulo 100 - Carctaerísticas de la Vivienda y del Hogar.sav.sav"))

##PENDING:
#Step 1: probablemente hay que filtrar por P207 == 1 y hace un group by CODIGO_HOGAR y quedarme con los máximos. 
#Necesito aquí el N de miembros del hogar (nmiembrosrecod) + datos sobre las habitaciones (P105C) y dormitorios  (p106uso)


#df_household_ <- read_sav(here::here("data-raw","ENPOVE_Capitulo 200 - Carctaerísticas de los Residentes del Hogar.sav.sav"))

#Step 2: luego debo hacer un merge de ambos dataframes y guardarlo sobre df_household y continuar

# names(df_household)
# df_household |> dplyr::select(CIUDAD) |> dplyr::distinct() |> dplyr::pull()

## Explore all content
#df_household |>  sjPlot::view_df()

df_householda <- df_household 

######## CREATE UNIQUE HOUSEHOLD ID
df_household <- df_household  |>
  dplyr::mutate(uuid = CODIGO_HOGAR)  |>
  dplyr::mutate(class = CIUDADES_DE_ESTUDIO)

######## DEPURACIÓN DE FILAS 
#### Filtramos fuera del análisis las viviendas donde no vivían personas de Venezuela*.
#df_household <- df_household  |>
#  filter(P15 == 1)
#### Borramos las filas donde la encuesta no llegó a su fin
df_household <- df_household  |>
  filter(RESULTADO_FINAL_VIVIENDA <3)

```
 




```{r, echo=F}
# mpi_result$index |>
#   gt::gt() |>
#   gt::tab_header(
#     title = 'MPI Results using 33% Poverty Cutoff'
#   ) |>
#   gt::fmt_number(
#     columns = 2:4,
#     decimals = 3
#   ) |>
#   gt::tab_options(
#     table.width = '100%',
#     table.font.size = 12,
#   )
## Contribution by dimension
# mpi_result$contribution
 
# mpi_result$contribution |> 
#   rename_all(~ stringr::str_remove(., '^(Health|Education|Living Standards)>')) |> 
#   gt::gt() |> 
#   gt::tab_header(
#     title = 'Contribution by Dimenstion and Indicator to MPI using 33% Poverty Cutoff'
#   ) |> 
#   gt:: tab_spanner(
#     label = "Health",
#     columns = 2:3
#   ) |> 
#   gt:: tab_spanner(
#     label = "Education",
#     columns = 4:5
#   ) |> 
#   gt:: tab_spanner(
#     label = "Living Standards",
#     columns = 6:11
#   ) |> 
#   gt::fmt_number(
#     columns = 2:11,
#     decimals = 1
#   ) |> 
#   gt::tab_options(
#     table.font.size = 12,
#   )
 
# mpi_result$headcount_ratio$uncensored |> 
#   rename_all(~ stringr::str_remove(., '^(Health|Education|Living Standards)>')) |> 
#   gt::gt() |> 
#   gt::tab_header(
#     title = 'Uncensored Headcount Ratio'
#   ) |> 
#   gt:: tab_spanner(
#     label = "Health",
#     columns = 2:3
#   ) |> 
#   gt:: tab_spanner(
#     label = "Education",
#     columns = 4:5
#   ) |> 
#   gt:: tab_spanner(
#     label = "Living Standards",
#     columns = 6:11
#   ) |> 
#   gt::fmt_number(
#     columns = 2:11,
#     decimals = 3
#   ) |> 
#   gt::tab_options(
#     table.font.size = 12,
#   )
 
# mpi_result$headcount_ratio$censored |> 
#   rename_all(~ stringr::str_remove(., '^(Health|Education|Living Standards)>')) |> 
#   gt::gt() |> 
#   gt::tab_header(
#     title = 'Censored Headcount Ratio using 33% Poverty Cutoff'
#   ) |> 
#   gt:: tab_spanner(
#     label = "Health",
#     columns = 2:3
#   ) |> 
#   gt:: tab_spanner(
#     label = "Education",
#     columns = 4:5
#   ) |> 
#   gt:: tab_spanner(
#     label = "Living Standards",
#     columns = 6:11
#   ) |> 
#   gt::fmt_number(
#     columns = 2:11,
#     decimals = 3
#   ) |> 
#   gt::tab_options(
#     table.font.size = 12,
#   )
#  
# mpi_result$deprivation_matrix$uncensored |> 
#   head() |> 
#   rename_all(~ stringr::str_remove(., '^(Health|Education|Living Standards)>')) |> 
#   gt::gt() |> 
#   gt::tab_header(
#     title = 'Uncensored Deprivation Matrix '
#   ) |> 
#   gt:: tab_spanner(
#     label = "Health",
#     columns = 2:3
#   ) |> 
#   gt:: tab_spanner(
#     label = "Education",
#     columns = 4:5
#   ) |> 
#   gt:: tab_spanner(
#     label = "Living Standards",
#     columns = 6:11
#   ) |> 
#   gt::fmt_number(
#     columns = 2,
#     decimals = 3
#   ) |> 
#   gt::tab_options(
#     table.font.size = 12,
#   )
#  
# mpi_result$deprivation_matrix$censored |> 
#   head() |> 
#   rename_all(~ stringr::str_remove(., '^(Health|Education|Living Standards)>')) |> 
#   gt::gt() |> 
#   gt::tab_header(
#     title = 'Censored Deprivation Matrix using 33% Poverty Cutoff'
#   ) |> 
#   gt:: tab_spanner(
#     label = "Health",
#     columns = 2:3
#   ) |> 
#   gt:: tab_spanner(
#     label = "Education",
#     columns = 4:5
#   ) |> 
#   gt:: tab_spanner(
#     label = "Living Standards",
#     columns = 6:11
#   ) |> 
#   gt::fmt_number(
#     columns = 2,
#     decimals = 3
#   ) |> 
#   gt::tab_options(
#     table.font.size = 12,
#   )
```


